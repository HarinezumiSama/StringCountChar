<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.Specialized" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#
    var methodNames = new[]
    {
        @"CountUsingLinqAndLambda",
        @"CountUsingLinqAndLocalFunction",
        @"CountUsingForEach",
        @"CountUsingForEachButNoBranching",
        @"CountUsingSimdWithUShortLimit",
        @"CountUsingSimd"
    };

    var firstMethodName = methodNames.First();
    var maxMethodNameLength = methodNames.Max(s => s.Length);
    var methodNamePadLength = maxMethodNameLength + 1;

    var vectorNameInfos = new OrderedDictionary
    {
        { "Vector", "true" },
        { "Vector64", "NETCOREAPP3_0_OR_GREATER" },
        { "Vector128", "NETCOREAPP3_0_OR_GREATER" },
        { "Vector256", "NETCOREAPP3_0_OR_GREATER" },
        { "Vector512", "NET8_0_OR_GREATER" }
    };

    var instructionSetInfos = new OrderedDictionary
    {
        { "Aes", "NETCOREAPP3_0_OR_GREATER" },
        { "Aes.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Avx", "NETCOREAPP3_0_OR_GREATER" },
        { "Avx.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Avx10v1", "NET9_0_OR_GREATER" },
        { "Avx10v1.X64", "NET9_0_OR_GREATER" },
        { "Avx10v1.V512", "NET9_0_OR_GREATER" },
        { "Avx10v1.V512.X64", "NET9_0_OR_GREATER" },
        { "Avx2", "NETCOREAPP3_0_OR_GREATER" },
        { "Avx2.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Avx512BW", "NET8_0_OR_GREATER" },
        { "Avx512BW.VL", "NET8_0_OR_GREATER" },
        { "Avx512BW.X64", "NET8_0_OR_GREATER" },
        { "Avx512CD", "NET8_0_OR_GREATER" },
        { "Avx512CD.VL", "NET8_0_OR_GREATER" },
        { "Avx512CD.X64", "NET8_0_OR_GREATER" },
        { "Avx512DQ", "NET8_0_OR_GREATER" },
        { "Avx512DQ.VL", "NET8_0_OR_GREATER" },
        { "Avx512DQ.X64", "NET8_0_OR_GREATER" },
        { "Avx512F", "NET8_0_OR_GREATER" },
        { "Avx512F.VL", "NET8_0_OR_GREATER" },
        { "Avx512F.X64", "NET8_0_OR_GREATER" },
        { "Avx512Vbmi", "NET8_0_OR_GREATER" },
        { "Avx512Vbmi.VL", "NET8_0_OR_GREATER" },
        { "Avx512Vbmi.X64", "NET8_0_OR_GREATER" },
        { "AvxVnni", "NET9_0_OR_GREATER" },
        { "AvxVnni.X64", "NET9_0_OR_GREATER" },
        { "Bmi1", "NETCOREAPP3_0_OR_GREATER" },
        { "Bmi1.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Bmi2", "NETCOREAPP3_0_OR_GREATER" },
        { "Bmi2.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Fma", "NETCOREAPP3_0_OR_GREATER" },
        { "Fma.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Lzcnt", "NETCOREAPP3_0_OR_GREATER" },
        { "Lzcnt.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Pclmulqdq", "NETCOREAPP3_0_OR_GREATER" },
        { "Pclmulqdq.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Popcnt", "NETCOREAPP3_0_OR_GREATER" },
        { "Popcnt.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse2", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse2.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse3", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse3.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse41", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse41.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse42", "NETCOREAPP3_0_OR_GREATER" },
        { "Sse42.X64", "NETCOREAPP3_0_OR_GREATER" },
        { "X86Base", "NET5_0_OR_GREATER" },
        { "X86Base.X64", "NET5_0_OR_GREATER" },
        { "X86Serialize", "NET7_0_OR_GREATER" },
        { "X86Serialize.X64", "NET7_0_OR_GREATER" },
    };
#>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.InteropServices;
#if NETCOREAPP3_0_OR_GREATER
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
#endif
using StringCountChar.Properties;

namespace StringCountChar
{
    internal static class TestExecutor
    {
        private static readonly string TestTextData = Resources.TestTextData;

        private static readonly char[] SearchChars = new[] { '\n', 'i', 'e' };
        private static readonly int[] IterationCounts = new[] { 10, 50, 100, 500, 1000 };

        private const string MismatchMessage = @"\x0020(ERROR: mismatch)";

        public static int Run()
        {
            Console.ResetColor();

            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine($@"CLR version: {RuntimeEnvironment.GetSystemVersion()}");
            Console.WriteLine();

            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.WriteLine($@"{nameof(Vector)}.{nameof(Vector.IsHardwareAccelerated)}: {Vector.IsHardwareAccelerated}");
#if NET7_0_OR_GREATER
            Console.WriteLine($@"{nameof(Vector64)}.{nameof(Vector64.IsHardwareAccelerated)}: {Vector64.IsHardwareAccelerated}");
            Console.WriteLine($@"{nameof(Vector128)}.{nameof(Vector128.IsHardwareAccelerated)}: {Vector128.IsHardwareAccelerated}");
            Console.WriteLine($@"{nameof(Vector256)}.{nameof(Vector256.IsHardwareAccelerated)}: {Vector256.IsHardwareAccelerated}");
#endif
#if NET8_0_OR_GREATER
            Console.WriteLine($@"{nameof(Vector512)}.{nameof(Vector512.IsHardwareAccelerated)}: {Vector512.IsHardwareAccelerated}");
#endif
            Console.WriteLine();

            Console.ForegroundColor = ConsoleColor.Magenta;
<#
    {
        string previousCondition = null;
        foreach (DictionaryEntry instructionSetInfo in instructionSetInfos)
        {
            var instructionSetName = (string)instructionSetInfo.Key;
            var condition = (string)instructionSetInfo.Value;

            var instructionSetNameParts = instructionSetName.Split('.');
            var instructionSetNameInfo = instructionSetNameParts
                .Aggregate(
                    new KeyValuePair<string, string>(string.Empty, string.Empty),
                    (acc, s) =>
                    {
                        var separator = string.IsNullOrEmpty(acc.Key) ? null : ".";
                        var current = acc.Key + separator + s;
                        return new KeyValuePair<string, string>(current, acc.Value + separator + $"{{nameof({current})}}");
                    });

            if (condition != previousCondition)
            {
                if (previousCondition != null)
                {
#>
#endif
<#
                }
#>
#if <#= condition #>
<#
            }
#>
            Console.WriteLine($@"<#= instructionSetNameInfo.Value #>.{nameof(<#= instructionSetNameInfo.Key #>.IsSupported)}: {<#= instructionSetName #>.IsSupported}");
<#
            previousCondition = condition;
        }

        if (previousCondition != null)
        {
#>
#endif
<#
        }
    }
#>
            Console.WriteLine();

            Console.ForegroundColor = ConsoleColor.Green;
<#
    {
        string previousCondition = null;
        foreach (DictionaryEntry vectorNameInfo in vectorNameInfos)
        {
            var vectorName = (string)vectorNameInfo.Key;
            var condition = (string)vectorNameInfo.Value;

            if (condition != previousCondition)
            {
                if (previousCondition != null)
                {
#>
#endif
<#
                }
#>
#if <#= condition #>
<#
            }
#>
            Console.WriteLine(Get<#= vectorName #>CountInfo<ushort>());
            Console.WriteLine(Get<#= vectorName #>CountInfo<uint>());
<#
            previousCondition = condition;
        }

        if (previousCondition != null)
        {
#>
#endif
<#
        }
    }
#>
            Console.WriteLine();

            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($@"{nameof(TestTextData)}.{nameof(TestTextData.Length)}: {TestTextData.Length:N0}");
            Console.ResetColor();

            Console.WriteLine();
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine(@"*** Warming up and validating results.");
            Console.ResetColor();

            foreach (var searchChar in SearchChars)
            {
                Console.WriteLine();
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine($@"* Search character: {GetSearchCharInfo(searchChar)}");
                Console.ResetColor();

<#
    foreach (var methodName in methodNames)
    {
#>
                var valueOf<#= methodName #> = TestTextData.<#= methodName #>(searchChar);
                Console.WriteLine(
                    $@"{nameof(StringHelper.<#= methodName #>).PadRight(<#= methodNamePadLength #>)}: {
                        valueOf<#= methodName #>:N0}<#
                        if (methodName != firstMethodName)
                        {
                            #>{
                        (valueOf<#= methodName #> == valueOf<#= firstMethodName #> ? null: MismatchMessage)}<#
                        } #>");

<#
    }
#>
            }

#if DEBUG
            Console.WriteLine();
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine(@"*** To run performance tests, compile this application in the Release configuration.");
            Console.ResetColor();
            return 1;
#else
            //// Tests
            foreach (var searchChar in SearchChars)
            {
                Console.WriteLine();
                Console.ForegroundColor = ConsoleColor.Magenta;
                Console.WriteLine(@"----------");
                Console.ResetColor();

                foreach (var iterationCount in IterationCounts)
                {
                    RunPerformanceTests(searchChar, iterationCount);
                }
            }

            return 0;
#endif
        }

<#
    foreach (DictionaryEntry vectorNameInfo in vectorNameInfos)
    {
        var vectorName = (string)vectorNameInfo.Key;
#>
#if <#= vectorNameInfo.Value #>
        private static string Get<#= vectorName #>CountInfo<T>()
            where T : struct
        {
            const string NotAvailable = "N/A";

            string countString;
            try
            {
#if NET7_0_OR_GREATER
                countString = <#= vectorName #><T>.IsSupported ? <#= vectorName #><T>.Count.ToString() : NotAvailable;
#else
                countString = <#= vectorName #><T>.Count.ToString();
#endif
            }
            catch (NotSupportedException)
            {
                countString = NotAvailable;
            }

            return $@"{nameof(<#= vectorName #>)}<{typeof(T).Name}>.{nameof(<#= vectorName #><T>.Count)}: {countString}";
        }
#endif

<#
    }
#>
#if !DEBUG
        private static void RunPerformanceTests(char searchChar, int iterationCount)
        {
            Console.WriteLine();
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine($@"*** [Running performance tests] Search character: {GetSearchCharInfo(searchChar)}. Iteration count: {iterationCount}.");
            Console.ResetColor();

            ////long? etalonTimeUs = null;

<#
    foreach (var methodName in methodNames)
    {
#>
            var timeOf<#= methodName #> = Test<#= methodName #>(searchChar, iterationCount, <#
                if (methodName == firstMethodName) { #>null<# } else { #>timeOf<#= firstMethodName #><# } #>);
<#
    }
#>
        }
#endif

        private static string GetSearchCharInfo(char searchChar)
            => $@"'\x{(ushort)searchChar:X4}'{(searchChar < '\x0020' ? string.Empty : $"\x0020('{searchChar}')")}";
<#
    foreach (var methodName in methodNames)
    {
#>

        private static long Test<#= methodName #>(char searchChar, int iterationCount, long? etalonTimeUs)
        {
            var totalCount = 0;

            var stopwatch = Stopwatch.StartNew();
            for (var index = 0; index < iterationCount; index++)
            {
                unchecked
                {
                    totalCount += TestTextData.<#= methodName #>(searchChar);
                }
            }
            stopwatch.Stop();
            Trace.Assert(totalCount.ToString().Length != 0);  // Just using the variable

            var timeUs = stopwatch.Elapsed.GetTotalIntegralMicroseconds();

            var speedComparisonString = string.Empty;
            if (etalonTimeUs.HasValue)
            {
                var ratio = (decimal)etalonTimeUs.Value / timeUs;
                speedComparisonString = $@" : {ratio,5:N1}X faster";
            }

            Console.WriteLine(
                $@"{nameof(StringHelper.<#= methodName #>).PadRight(<#= methodNamePadLength #>)}: {timeUs,10:N0} us{speedComparisonString}");

            return timeUs;
        }
<#  } #>
    }
}